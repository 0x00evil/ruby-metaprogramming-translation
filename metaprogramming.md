# 元编程
200年前，人类发明了纺织机，这是第一个被用来控制卡片的使用的机器－卡片上的洞被用来控制应在衣服上的花纹的样式。但是请想像一下，我们不创造织物，而是用纺织机创造更多的卡片，这些卡片又可以反哺机器。这个机器可以用来创造新的可以执行的编程。那就是元编程－**写可以写代码的代码**。


编程就是建造抽象层。当你在解决问题的时候，就是在把硅的世界和我们居住的流动的世界连接起来。一些编程语言－比如说C－更加亲近机器。C代码和你的应用的问题域会很大。其他的语言－可能是Ruby－提供了更高层次的抽象，并且因此可以让你以更加接近问题域的方式开始编码。因为这个原因，大多数人认为抽象层次更高的语言对于应用的开发，是一个更好的起点（尽管他们对具体的语言选择还是会有争议）。

但是，当你在元编程的时候，你就不再受限于你的语言内建的抽象集合了。取而代之的是，你创造新的抽象层，然后把它集成到你的宿主语言中。效果上，你创造了一个新的，问题域明确的编程语言－一个可以让你直接表达你的特定问题的概念的语言。

Ruby让元编程很简单。从而，大多数的高级Ruby程序员会使用元编程技术简化他们的代码。这一章将会向你展示如何使用它。这一章不是元编程技术的详尽调查。取而代之的是，我们将会看一下是什么Ruby原则让元编程成为可能。从这里开始，你将会发明自己的元编程写法。

## 对象和类
类和对象很明显是Ruby的核心，但是第一眼看上去可能会有一点困惑。这里好像有很多的概念：类，对象，类对象，实例对象，类方法，单例方法，以及虚拟类。在现实中，Ruby只有一种类和对象的结构。

一个Ruby对象由三部分构成：一个标识集合，一些实例变量和一个相关的类。一个Ruby类是类Class的一个对象。它包含了一个对象应该有的对象，外加一个方法定义集合和一个超类引用。

对，基本上就是这些。根据这些概念你可以自己探索出元编程的所有细节。不过，一如既往，魔鬼会隐藏一些细节，所以让我们来挖更深一点吧。

### self和方法调用
Ruby有当前对象（current object）的概念。当前对象被内建的，只读的self变量引用。self在Ruby程序中有两个非常重要的角色。

首先，self控制Ruby如何找到实例变量。我们之前就说过，每一个对象都携带有一个变量集合。当你想要使用这些变量的时候，Ruby从self引用的对象中寻找。

第二，self在方法调用方面扮演了很重要的角色。在Ruby中，每一个方法调用都跟一个对象有关。这个对象被叫做调用的接收者。当你做一个蕾丝item.size的调用的时候，被item变量引用的对象就是接收者，而size就是要被调用的方法。

如果你做一个类似**puts "hi"**的调用，这里没有明确的接收者。在这种情况下，Ruby会使用当前对象，self，做为接收者。Ruby在self的类里面查找要被调用的方法（在这个例子中就是puts）。如果没有在这个类中找到这个方法，那么就在这个类的超类中寻找，然后是超类的超类，直到到达类继承链的顶端。

当你使用明确的接收者去做一个方法调用的时候（例如items.size），过程是令人惊讶的相似。唯一的改变就是－但是非常中的一个－就是self的值会在方法调用期间发生变化的事实。在开始方法查找的过程之前，Ruby会把self的值设置成为接收者（在这个例子中就是被item引用的对象）。然后，方法调用结束之后，Ruby会把self的值设置成为方法调用之前的值。

让发我们来看一下在现实情况下，这是如何工作的。这里一个简单的程序：
> class Test
> 
>   def one
>   
>      @var = 99
>      
>      two
>   end
>   
>   def two
>   
>     puts @var
>     
>   end
>   
> end
> 
> t = Test.new
> 
> t.one
> 
> *produce:*
> 
> 99

倒数第二行的Test.new调用创造了一个新的类Test的对象，把这个对象复制给了变量t。然后，在下一行，我们调用了方法t.one。为了执行这个调用，Ruby把self设置成为t的值，然后在它t的类里面寻找方法one。Ruby发现这个放在在第二行被定义，然后调用了它。

在这个方法里面，我们把实例变量设置成为99.这个实力变量将会跟当前对象绑定。那个对象是什么？t.one的调用的时候，会把self的设置成为t，所以在one这个方法中，self将会就是那个特定的class Test的对象。

在下一行，*one*调用了*two*。因为这里没有明确的接收者，所以self的值并没有改变。当Ruby寻找two这个方法的时候，它将会在Test，t的类，中寻找。

方法two引用一个实例变量@var。又一次，Ruby会在当前对象中查找这个变量，然后找到了被one设置的同一个变量。

对puts和two的调用是一样的。又一次，因为没有没有明确的接收者，self没有改变。Ruby在当前对象的类中寻找puts方法，但是它没有找到。然后它会在Test类的超类中寻找，也就是Object中寻找。又一次，Ruby还是没有找到puts方法，但是Object混合了Kernel模块。我们将会稍后谈到；现在被混合进的模块就是超类一样。Kernel模块定义了puts方法，所以这个方法被找到，然后执行了。

two和one方法返回之后，Ruby重新设置了self的值，也就是t.one之前的self的值。

这个解释可能和费劲，但是理解这一点对于掌握元编程来说非常重要。

### self和类定义

我们看到使用一个明确的接收者调用一个方法，会改变self的值。可能很惊讶，类定义也会改变self的值。这是因为在Ruby中，类定义也是可执行代码－如果我们要执行代码，那么我们就需要一个当前对象。一个见的测试可以说明这个对象是什么：

>class Test

> puts "In the definition of class Test"
> 
> puts "self= #{self}"
>
> puts "Class of self = #{self.class}"
>
> end

> *produce*:

> In the definition of class Test

>self = Test

> Class of self = Class

在类定义中，self被设置成为正在被定义的类的类对象。这意味着在类定义中设置的实例变量对于类方法是可行的（因为这个变量咋被定义的和方法执行的时候，是保持不变的）。

> class Test
>
>    @var = 99
>
>     def self.value_of_var
>
>      @var 
>
>      end
>
> end

> Test.value_of_var  #=> 99

在类定义期间把self的值设置成成为class，被证明是一个非常明知的决定，但是想要知道为什么，我们首先需要看一下单例（singleton）。

## 	单例（Singleton）
Ruby让你可以定义特定于某个对象的方法。它们被称作*singleton methods*。

























